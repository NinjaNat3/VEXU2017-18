#pragma config(Sensor, in1,    shoulderMeasure, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  driveRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  driveLeft,      sensorQuadEncoder)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop, encoderPort, None)
#pragma config(Motor,  port2,           driveR1,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveR2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveL2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           shoulderL1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           shoulderL2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           shoulderR1,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           shoulderR2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          lift,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//this is a test comment
float speedRight;
float speedLeft;
float maxShoulderSpeed = 63;
float speedShoulder;
float maxClawSpeed = 63;
float minClawSpeed = 25;
float speedClaw;
float maxLiftSpeed = 63;
float speedLift;

float previousSpeedRight = 0;
float previousSpeedLeft = 0;
float previousShoulder = 0;
float previousClaw = 0;
float previousLift = 0;

float errorCoeff = 4/5;

float errorSpeedRight;
float errorSpeedLeft;
float errorShoulder;
float errorClaw;
float errorLift;

float maxValue = 127;
float minValue = -127;
float maxproportion;
float minproportion;

float currentPos = 0;
bool tog = false;

//AutonCode
void resetValues()
{
	SensorValue(driveRight) = 0;
	SensorValue(driveLeft) = 0;
}


void pre_auton()
{
		resetValues();
	  bStopTasksBetweenModes = true;
}

task autonomous()
{
	pre_auton();
}

void drive()
{
	speedRight = vexRT[Ch3] + vexRT[Ch4];
	speedLeft = vexRT[Ch2] - vexRT[Ch4];

	float speedArray[2] 	= {speedRight, speedLeft};
	float maximum 		= - 127;
	int maxPos 		= 0;
	float minimum 		= 127;
	int minPos 		= 0;

	for (int i = 0; i < 2; i++)
	{
		if(speedArray[i] > maximum)
		{
			maximum = speedArray[i];
			maxPos 	= i;
		}
		if(speedArray[i] < minimum)
		{
			minimum = speedArray[i];
			minPos 	= i;
		}
	}

	if (maximum > maxValue)
		{
			if (minimum < minValue)
			{
				maxproportion 	= maxValue / speedArray[maxPos];
				minproportion 	= minValue / speedArray[minPos];

				if (maxproportion < minproportion)
				{
					speedRight = maxproportion * speedArray[0];
					speedLeft 	= maxproportion * speedArray[1];
				}
				else
				{
					speedRight = minproportion * speedArray[0];
					speedLeft 	= minproportion * speedArray[1];
				}
			}
			else
			{
				maxproportion 	= maxValue / speedArray[maxPos];
				speedRight = maxproportion * speedArray[0];
				speedLeft	= maxproportion * speedArray[1];
			}
		}
		else if (minimum < minValue)
		{
			minproportion 	= minValue / speedArray[minPos];
			speedRight = minproportion * speedArray[0];
			speedLeft 	= minproportion * speedArray[1];
		}

	errorSpeedRight = errorCoeff * (speedRight - previousSpeedRight);
	errorSpeedLeft = errorCoeff * (speedLeft - previousSpeedLeft);

	motor[driveR1] = speedRight - errorSpeedRight;
	motor[driveR2] = speedRight - errorSpeedRight;
	motor[driveL1] = speedLeft - errorSpeedLeft;
	motor[driveL2] = speedLeft - errorSpeedLeft;

	previousSpeedRight = speedRight - errorSpeedRight;
	previousSpeedLeft = speedRight - errorSpeedRight;
}

void liftShoulder()
{
	if (vexRT[Btn5U] == 1)
	{
		errorShoulder	= errorCoeff * (maxShoulderSpeed - previousShoulder);

		speedShoulder 	= maxShoulderSpeed - errorShoulder;

		motor[shoulderR1]	= speedShoulder;
		motor[shoulderR2]	= speedShoulder;
		motor[shoulderL1]	= speedShoulder;
		motor[shoulderL2]	= speedShoulder;

		previousShoulder 	= speedShoulder;
		tog = true;
		currentPos = SensorValue[shoulderMeasure];
	}

	//Lower
	else if (vexRT[Btn5D] == 1)
	{
		errorShoulder	= errorCoeff * (-maxShoulderSpeed - previousShoulder);

		speedShoulder 	= -maxShoulderSpeed - errorShoulder;

		motor[shoulderR1]	= speedShoulder;
		motor[shoulderR2]	= speedShoulder;
		motor[shoulderL1]	= speedShoulder;
		motor[shoulderL2]	= speedShoulder;

		previousShoulder 	= speedShoulder;
		tog = false;
		currentPos = SensorValue[shoulderMeasure];
	}

		//Stop
	else
	{
		if ((currentPos > 500) && (currentPos < 3000))
		{
			if(tog)
			{
				if(currentPos - 100 < SensorValue[shoulderMeasure])
				{
					speedShoulder = 15;
					motor[shoulderR1]	= speedShoulder;
					motor[shoulderR2]	= speedShoulder;
					motor[shoulderL1]	= speedShoulder;
					motor[shoulderL2]	= speedShoulder;
					previousShoulder = 15;
				}
				else
				{
					tog = false;
					speedShoulder = -15;
					motor[shoulderR1]	= speedShoulder;
					motor[shoulderR2]	= speedShoulder;
					motor[shoulderL1]	= speedShoulder;
					motor[shoulderL2]	= speedShoulder;
					previousShoulder = -15;
				}
			}
			else
			{
				if(currentPos + 100 > SensorValue[shoulderMeasure])
				{
					speedShoulder = -15;
					motor[shoulderR1]	= speedShoulder;
					motor[shoulderR2]	= speedShoulder;
					motor[shoulderL1]	= speedShoulder;
					motor[shoulderL2]	= speedShoulder;
					previousShoulder = -15;
				}
				else
				{
					tog = true;
					speedShoulder = 15;
					motor[shoulderR1]	= speedShoulder;
					motor[shoulderR2]	= speedShoulder;
					motor[shoulderL1]	= speedShoulder;
					motor[shoulderL2]	= speedShoulder;
					previousShoulder = 15;
				}
			}

		}
		else
		{
			errorShoulder	= errorCoeff * previousShoulder;

			speedShoulder 	= errorShoulder;

			motor[shoulderR1]	= speedShoulder;
			motor[shoulderR2]	= speedShoulder;
			motor[shoulderL1]	= speedShoulder;
			motor[shoulderL2]	= speedShoulder;

			previousShoulder 	= speedShoulder;
			currentPos = SensorValue[shoulderMeasure];
		}
	}
}

void liftClaw()
{
	if (vexRT[Btn7L] == 1)
		{
			errorClaw	= errorCoeff * (maxClawSpeed - previousClaw);

			speedClaw 	= maxClawSpeed - errorClaw;

			motor[claw]	= speedClaw;

			previousClaw 	= speedClaw;
		}

		//Lower
		else if (vexRT[Btn7R] == 1)
		{
			errorClaw	= errorCoeff * (-minClawSpeed - previousClaw);

			speedClaw 	= -maxClawSpeed - errorClaw;

			motor[claw]	= speedClaw;

			previousClaw 	= speedClaw;
		}

		//Stop
		else
		{
			errorClaw	= errorCoeff * previousClaw;

			speedClaw 	= errorClaw;

			motor[claw]	= speedClaw;

			previousClaw 	= speedClaw;
		}
}

void liftGoal() {
if (vexRT[Btn6U] == 1)
		{
			errorLift	= errorCoeff * (maxLiftSpeed - previousLift);

			speedLift 	= maxLiftSpeed - errorLift;

			motor[lift]	= speedLift;

			previousLift 	= speedLift;
		}

		//Lower
		else if (vexRT[Btn6D] == 1)
		{
			errorLift	= errorCoeff * (-maxLiftSpeed - previousLift);

			speedLift 	= -maxLiftSpeed - errorLift;

			motor[lift]	= speedLift;

			previousLift 	= speedLift;
		}

		//Stop
		else
		{


			errorLift	= errorCoeff * previousLift;

			speedLift 	= errorLift;

			motor[lift]	= speedLift;

			previousLift 	= speedLift;
		}
}

task usercontrol()
{
	while(true){
		drive();
		liftShoulder();
		liftClaw();
		liftGoal();
		wait1Msec(50);
	}
}
